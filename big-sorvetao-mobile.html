<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">
<title>Big Sorvet√£o - O Guardi√£o da Receita Secreta</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Bungee+Shade&family=Fredoka:wght@400;600;700&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

  html, body {
    background: #1a0a2e;
    overflow: hidden;
    height: 100%;
    width: 100%;
    font-family: 'Fredoka', sans-serif;
    touch-action: none;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
    position: fixed;
  }

  canvas { display: block; }

  #hud {
    position: fixed;
    top: 8px;
    left: 50%;
    transform: translateX(-50%);
    display: none;
    gap: 10px;
    align-items: center;
    z-index: 20;
    pointer-events: none;
  }

  .hud-item {
    background: rgba(0,0,0,0.65);
    border: 2px solid #00e5ff;
    border-radius: 10px;
    padding: 4px 12px;
    color: #fff;
    font-size: 11px;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 5px;
    backdrop-filter: blur(8px);
    text-shadow: 0 0 8px rgba(0,229,255,0.5);
  }

  .hud-item .label { color: #00e5ff; font-size: 9px; text-transform: uppercase; letter-spacing: 1px; }
  .hud-item .value { font-family: 'Bungee Shade', cursive; font-size: 16px; color: #ffd600; }

  #health-bar-container {
    position: fixed;
    top: 48px;
    left: 50%;
    transform: translateX(-50%);
    width: 200px;
    height: 14px;
    background: rgba(0,0,0,0.7);
    border: 2px solid #00e5ff;
    border-radius: 8px;
    overflow: hidden;
    z-index: 20;
    pointer-events: none;
    display: none;
  }

  #health-bar {
    height: 100%;
    width: 100%;
    background: linear-gradient(90deg, #00e5ff, #00bcd4);
    border-radius: 6px;
    transition: width 0.3s ease;
    box-shadow: 0 0 10px rgba(0,229,255,0.5);
  }

  #health-label {
    position: fixed;
    top: 64px;
    left: 50%;
    transform: translateX(-50%);
    color: #00e5ff;
    font-size: 8px;
    font-weight: 700;
    letter-spacing: 1.5px;
    text-transform: uppercase;
    z-index: 20;
    pointer-events: none;
    text-shadow: 0 0 8px rgba(0,229,255,0.5);
    display: none;
  }

  /* ====== TOUCH CONTROLS ====== */
  #touch-controls {
    position: fixed;
    bottom: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 30;
    pointer-events: none;
    display: none;
  }

  #joystick-zone {
    position: absolute;
    bottom: 20px;
    left: 20px;
    width: 140px;
    height: 140px;
    pointer-events: all;
  }

  #joystick-base {
    position: absolute;
    width: 120px;
    height: 120px;
    border-radius: 50%;
    background: rgba(0,229,255,0.12);
    border: 2px solid rgba(0,229,255,0.35);
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
  }

  #joystick-knob {
    position: absolute;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: radial-gradient(circle, rgba(0,229,255,0.6), rgba(0,229,255,0.25));
    border: 2px solid rgba(0,229,255,0.7);
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    transition: none;
  }

  #fire-zone {
    position: absolute;
    bottom: 20px;
    right: 20px;
    width: 160px;
    height: 160px;
    pointer-events: all;
  }

  #fire-btn {
    position: absolute;
    width: 90px;
    height: 90px;
    border-radius: 50%;
    background: radial-gradient(circle, rgba(255,214,0,0.5), rgba(255,214,0,0.15));
    border: 3px solid rgba(255,214,0,0.6);
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 28px;
    color: #ffd600;
    text-shadow: 0 0 10px rgba(255,214,0,0.6);
    pointer-events: all;
  }

  #fire-btn::after {
    content: 'üç®';
    font-size: 32px;
  }

  #aim-zone {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: all;
    z-index: -1;
  }

  /* ====== SCREENS ====== */
  #start-screen, #game-over-screen, #win-screen {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 100;
    pointer-events: all;
    padding: 20px;
  }

  #start-screen {
    background: radial-gradient(ellipse at center, #2a1a4e 0%, #1a0a2e 70%);
  }

  #game-over-screen, #win-screen {
    background: rgba(10,5,20,0.94);
    display: none;
  }

  .screen-title {
    font-family: 'Bungee Shade', cursive;
    font-size: clamp(24px, 6vw, 52px);
    color: #ffd600;
    text-shadow: 0 0 25px rgba(255,214,0,0.6), 0 3px 0 #c6a700;
    margin-bottom: 8px;
    text-align: center;
    line-height: 1.2;
  }

  .screen-subtitle {
    font-size: clamp(13px, 3vw, 18px);
    color: #00e5ff;
    margin-bottom: 30px;
    text-align: center;
    max-width: 400px;
    line-height: 1.5;
  }

  .btn-play {
    background: linear-gradient(135deg, #ffd600, #ffab00);
    color: #1a0a2e;
    border: none;
    padding: 14px 44px;
    font-size: 20px;
    font-family: 'Fredoka', sans-serif;
    font-weight: 700;
    border-radius: 50px;
    cursor: pointer;
    transition: all 0.3s ease;
    text-transform: uppercase;
    letter-spacing: 2px;
    box-shadow: 0 6px 25px rgba(255,214,0,0.4);
    pointer-events: all;
    -webkit-tap-highlight-color: transparent;
  }

  .btn-play:active {
    transform: scale(0.95);
    box-shadow: 0 3px 15px rgba(255,214,0,0.5);
  }

  .game-over-title {
    font-family: 'Bungee Shade', cursive;
    font-size: clamp(24px, 6vw, 48px);
    color: #ff1744;
    text-shadow: 0 0 25px rgba(255,23,68,0.6);
    margin-bottom: 12px;
  }

  .win-title {
    font-family: 'Bungee Shade', cursive;
    font-size: clamp(22px, 5.5vw, 44px);
    color: #00e676;
    text-shadow: 0 0 25px rgba(0,230,118,0.6);
    margin-bottom: 12px;
  }

  .final-score {
    font-size: 20px;
    color: #ffd600;
    margin-bottom: 25px;
  }

  .controls-info {
    margin-top: 25px;
    color: rgba(255,255,255,0.45);
    font-size: 12px;
    text-align: center;
    line-height: 1.8;
  }

  .controls-info span { color: #ffd600; font-weight: 600; }

  .ice-cream-logo {
    font-size: 56px;
    margin-bottom: 15px;
    animation: bounce 2s ease-in-out infinite;
  }

  @keyframes bounce {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-12px); }
  }

  /* Desktop cursor */
  @media (hover: hover) and (pointer: fine) {
    body { cursor: crosshair; }
  }
</style>
</head>
<body>

<div id="hud">
  <div class="hud-item">
    <div><div class="label">Pontos</div><div class="value" id="score-val">0</div></div>
  </div>
  <div class="hud-item">
    <div><div class="label">Onda</div><div class="value" id="wave-val">1/5</div></div>
  </div>
  <div class="hud-item">
    <div><div class="label">Inimigos</div><div class="value" id="enemies-val">0</div></div>
  </div>
</div>

<div id="health-label">üç¶ RECEITA SECRETA üç¶</div>
<div id="health-bar-container"><div id="health-bar"></div></div>

<!-- Touch Controls -->
<div id="touch-controls">
  <div id="aim-zone"></div>
  <div id="joystick-zone">
    <div id="joystick-base"></div>
    <div id="joystick-knob"></div>
  </div>
  <div id="fire-zone">
    <div id="fire-btn"></div>
  </div>
</div>

<!-- Screens -->
<div id="start-screen">
  <div class="ice-cream-logo">üç®</div>
  <div class="screen-title">BIG SORVET√ÉO</div>
  <div class="screen-subtitle">
    A receita secreta est√° em perigo! Invasores querem roubar o segredo do sorvete mais famoso do mundo.
    Voc√™ √© o Guardi√£o ‚Äî defenda com sua concha de sorvete!
  </div>
  <button class="btn-play" id="btn-start">DEFENDER!</button>
  <div class="controls-info" id="controls-text"></div>
</div>

<div id="game-over-screen">
  <div class="game-over-title">RECEITA ROUBADA!</div>
  <div class="screen-subtitle">Os invasores conseguiram roubar a receita secreta do Big Sorvet√£o...</div>
  <div class="final-score">Pontua√ß√£o: <span id="final-score-val">0</span></div>
  <button class="btn-play" id="btn-restart">TENTAR NOVAMENTE</button>
</div>

<div id="win-screen">
  <div class="ice-cream-logo">üèÜ</div>
  <div class="win-title">RECEITA PROTEGIDA!</div>
  <div class="screen-subtitle">Voc√™ defendeu a receita secreta do Big Sorvet√£o! O sorvete mais famoso do mundo est√° a salvo!</div>
  <div class="final-score">Pontua√ß√£o Final: <span id="win-score-val">0</span></div>
  <button class="btn-play" id="btn-win-restart">JOGAR NOVAMENTE</button>
</div>

<canvas id="game"></canvas>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// ====== DETECT DEVICE ======
const isMobile = /Android|iPhone|iPad|iPod|webOS|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
  || (navigator.maxTouchPoints > 0 && window.innerWidth < 1024);

// Show appropriate controls info
document.getElementById('controls-text').innerHTML = isMobile
  ? '<span>Joystick esquerdo</span> ‚Äî Mover &nbsp;|&nbsp; <span>Toque na tela</span> ‚Äî Mirar &nbsp;|&nbsp; <span>Bot√£o üç®</span> ‚Äî Atirar<br>Sobreviva √†s 5 ondas de invasores!'
  : '<span>WASD / Setas</span> ‚Äî Mover &nbsp;|&nbsp; <span>Mouse</span> ‚Äî Mirar &nbsp;|&nbsp; <span>Clique</span> ‚Äî Atirar bolas de sorvete<br>Sobreviva √†s 5 ondas de invasores!';

// ====== RESIZE ======
function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);
window.addEventListener('orientationchange', () => setTimeout(resize, 200));

// ====== GAME STATE ======
let gameState = 'menu';
let score = 0;
let wave = 1;
const maxWaves = 5;
let waveAnnounce = '';
let waveAnnounceTimer = 0;
let recipeHealth = 100;
let shakeTimer = 0;
let particles = [];
let bullets = [];
let enemies = [];
let powerups = [];
let enemiesLeftInWave = 0;
let spawnTimer = 0;
let spawnInterval = 90;
let waveTransition = false;

// ====== INPUT ======
const keys = {};
window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

let mouse = { x: 0, y: 0, active: false };
let joystickInput = { x: 0, y: 0 };
let autoFireInterval = null;
let fireHeld = false;

// Mouse (desktop)
canvas.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; mouse.active = true; });
canvas.addEventListener('click', e => { if (gameState === 'playing' && !isMobile) shoot(); });

// ====== TOUCH JOYSTICK ======
const joystickZone = document.getElementById('joystick-zone');
const joystickKnob = document.getElementById('joystick-knob');
let joystickTouchId = null;
let joystickCenter = { x: 0, y: 0 };

function getJoystickCenter() {
  const rect = joystickZone.getBoundingClientRect();
  return { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
}

joystickZone.addEventListener('touchstart', e => {
  e.preventDefault();
  const touch = e.changedTouches[0];
  joystickTouchId = touch.identifier;
  joystickCenter = getJoystickCenter();
  updateJoystick(touch.clientX, touch.clientY);
}, { passive: false });

joystickZone.addEventListener('touchmove', e => {
  e.preventDefault();
  for (const touch of e.changedTouches) {
    if (touch.identifier === joystickTouchId) {
      updateJoystick(touch.clientX, touch.clientY);
    }
  }
}, { passive: false });

joystickZone.addEventListener('touchend', e => {
  for (const touch of e.changedTouches) {
    if (touch.identifier === joystickTouchId) {
      joystickTouchId = null;
      joystickInput.x = 0;
      joystickInput.y = 0;
      joystickKnob.style.transform = 'translate(-50%, -50%)';
    }
  }
});
joystickZone.addEventListener('touchcancel', e => {
  joystickTouchId = null;
  joystickInput.x = 0;
  joystickInput.y = 0;
  joystickKnob.style.transform = 'translate(-50%, -50%)';
});

function updateJoystick(tx, ty) {
  const maxDist = 45;
  let dx = tx - joystickCenter.x;
  let dy = ty - joystickCenter.y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  if (dist > maxDist) {
    dx = (dx / dist) * maxDist;
    dy = (dy / dist) * maxDist;
  }
  joystickKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
  joystickInput.x = dx / maxDist;
  joystickInput.y = dy / maxDist;
}

// ====== TOUCH AIM (tap anywhere on screen to aim) ======
const aimZone = document.getElementById('aim-zone');
let aimTouchId = null;

aimZone.addEventListener('touchstart', e => {
  e.preventDefault();
  const touch = e.changedTouches[0];
  aimTouchId = touch.identifier;
  mouse.x = touch.clientX;
  mouse.y = touch.clientY;
  mouse.active = true;
}, { passive: false });

aimZone.addEventListener('touchmove', e => {
  e.preventDefault();
  for (const touch of e.changedTouches) {
    if (touch.identifier === aimTouchId) {
      mouse.x = touch.clientX;
      mouse.y = touch.clientY;
    }
  }
}, { passive: false });

aimZone.addEventListener('touchend', e => {
  for (const touch of e.changedTouches) {
    if (touch.identifier === aimTouchId) {
      aimTouchId = null;
    }
  }
});

// ====== FIRE BUTTON ======
const fireBtn = document.getElementById('fire-btn');

fireBtn.addEventListener('touchstart', e => {
  e.preventDefault();
  e.stopPropagation();
  fireHeld = true;
  if (gameState === 'playing') shoot();
  autoFireInterval = setInterval(() => {
    if (gameState === 'playing' && fireHeld) shoot();
  }, 150);
}, { passive: false });

fireBtn.addEventListener('touchend', e => {
  e.preventDefault();
  fireHeld = false;
  clearInterval(autoFireInterval);
});
fireBtn.addEventListener('touchcancel', e => {
  fireHeld = false;
  clearInterval(autoFireInterval);
});

// Prevent default on entire document for mobile
document.addEventListener('touchmove', e => { if (gameState === 'playing') e.preventDefault(); }, { passive: false });

// ====== PLAYER ======
const player = {
  x: 0, y: 0,
  w: 40, h: 56,
  speed: 4,
  angle: 0,
  shootCooldown: 0,
  invincible: 0,
};

const recipe = { x: 0, y: 0, radius: 30 };

function initGame() {
  score = 0;
  wave = 1;
  recipeHealth = 100;
  enemies = [];
  bullets = [];
  particles = [];
  powerups = [];
  player.x = canvas.width / 2;
  player.y = canvas.height / 2 - 80;
  recipe.x = canvas.width / 2;
  recipe.y = canvas.height / 2;
  shakeTimer = 0;
  // Default aim toward top
  if (!mouse.active) {
    mouse.x = canvas.width / 2;
    mouse.y = 0;
  }
  startWave(1);
  updateHUD();
}

function startWave(w) {
  wave = w;
  const totalEnemies = 5 + w * 4;
  enemiesLeftInWave = totalEnemies;
  spawnTimer = 60;
  spawnInterval = Math.max(30, 90 - w * 12);
  waveTransition = false;
  waveAnnounce = `ONDA ${w}`;
  waveAnnounceTimer = 120;
}

function shoot() {
  if (player.shootCooldown > 0) return;
  const angle = Math.atan2(mouse.y - player.y, mouse.x - player.x);
  const speed = 10;
  const colors = ['#ff6b9d','#c8e6c9','#fff9c4','#b3e5fc','#f8bbd0','#d1c4e9','#ffe0b2'];
  bullets.push({
    x: player.x + Math.cos(angle) * 25,
    y: player.y + Math.sin(angle) * 25,
    vx: Math.cos(angle) * speed,
    vy: Math.sin(angle) * speed,
    radius: 8,
    color: colors[Math.floor(Math.random() * colors.length)],
    life: 80,
  });
  player.shootCooldown = 12;
  for (let i = 0; i < 4; i++) {
    particles.push({
      x: player.x + Math.cos(angle) * 25,
      y: player.y + Math.sin(angle) * 25,
      vx: Math.cos(angle + Math.PI + (Math.random()-0.5)) * (2+Math.random()*2),
      vy: Math.sin(angle + Math.PI + (Math.random()-0.5)) * (2+Math.random()*2),
      life: 20, maxLife: 20, radius: 3, color: '#ffd600',
    });
  }
}

function spawnEnemy() {
  if (enemiesLeftInWave <= 0) return;
  enemiesLeftInWave--;
  const side = Math.floor(Math.random() * 4);
  let x, y;
  switch(side) {
    case 0: x = -30; y = Math.random() * canvas.height; break;
    case 1: x = canvas.width + 30; y = Math.random() * canvas.height; break;
    case 2: x = Math.random() * canvas.width; y = -30; break;
    case 3: x = Math.random() * canvas.width; y = canvas.height + 30; break;
  }
  const weights = wave < 3 ? [0.7, 0.2, 0.1] : wave < 4 ? [0.5, 0.3, 0.2] : [0.3, 0.35, 0.35];
  const r = Math.random();
  let type = 'grunt';
  if (r > weights[0] + weights[1]) type = 'tank';
  else if (r > weights[0]) type = 'fast';

  const enemy = {
    x, y, type,
    radius: type === 'tank' ? 22 : type === 'fast' ? 14 : 18,
    speed: type === 'fast' ? 2.5 : type === 'tank' ? 0.8 : 1.4,
    hp: type === 'tank' ? 4 : type === 'fast' ? 1 : 2,
    maxHp: type === 'tank' ? 4 : type === 'fast' ? 1 : 2,
    damage: type === 'tank' ? 15 : 8,
    color: type === 'tank' ? '#ff1744' : type === 'fast' ? '#ff9100' : '#e040fb',
    flash: 0, attackCooldown: 0,
  };
  enemy.speed *= (1 + (wave - 1) * 0.1);
  enemies.push(enemy);
}

function updateHUD() {
  document.getElementById('score-val').textContent = score;
  document.getElementById('wave-val').textContent = `${wave}/${maxWaves}`;
  document.getElementById('enemies-val').textContent = enemies.length + enemiesLeftInWave;
  const hb = document.getElementById('health-bar');
  hb.style.width = Math.max(0, recipeHealth) + '%';
  if (recipeHealth < 30) hb.style.background = 'linear-gradient(90deg, #ff1744, #ff5252)';
  else if (recipeHealth < 60) hb.style.background = 'linear-gradient(90deg, #ffd600, #ffab00)';
  else hb.style.background = 'linear-gradient(90deg, #00e5ff, #00bcd4)';
}

function addExplosion(x, y, color, count=12) {
  for (let i = 0; i < count; i++) {
    const angle = (Math.PI * 2 / count) * i + Math.random() * 0.3;
    const speed = 2 + Math.random() * 4;
    particles.push({ x, y, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed, life: 30+Math.random()*20, maxLife: 50, radius: 2+Math.random()*4, color });
  }
}

function showUI(show) {
  const d = show ? 'flex' : 'none';
  const db = show ? 'block' : 'none';
  document.getElementById('hud').style.display = d;
  document.getElementById('health-bar-container').style.display = db;
  document.getElementById('health-label').style.display = db;
  if (isMobile) document.getElementById('touch-controls').style.display = db;
}

// ====== DRAWING ======

function drawPlayer() {
  ctx.save();
  ctx.translate(player.x, player.y);
  const angle = Math.atan2(mouse.y - player.y, mouse.x - player.x);
  player.angle = angle;

  // Body (cyan)
  ctx.fillStyle = '#00e5ff';
  ctx.beginPath();
  ctx.ellipse(0, 4, 16, 22, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.strokeStyle = '#0097a7';
  ctx.lineWidth = 2;
  ctx.stroke();

  // Apron
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.moveTo(-12, -2); ctx.lineTo(12, -2); ctx.lineTo(10, 22); ctx.lineTo(-10, 22);
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle = '#bbb';
  ctx.lineWidth = 1;
  ctx.stroke();

  // Apron pocket
  ctx.fillStyle = '#eee';
  ctx.fillRect(-6, 8, 12, 8);
  ctx.strokeStyle = '#bbb';
  ctx.strokeRect(-6, 8, 12, 8);

  // Apron straps
  ctx.strokeStyle = '#ddd';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(-10, -2); ctx.lineTo(-6, -18);
  ctx.moveTo(10, -2); ctx.lineTo(6, -18);
  ctx.stroke();

  // Head
  ctx.fillStyle = '#ffcc80';
  ctx.beginPath();
  ctx.arc(0, -18, 12, 0, Math.PI*2);
  ctx.fill();
  ctx.strokeStyle = '#e6a54a';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Hat (yellow)
  ctx.fillStyle = '#ffd600';
  ctx.beginPath();
  ctx.ellipse(0, -28, 16, 6, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(-10, -28); ctx.lineTo(-8, -40); ctx.lineTo(8, -40); ctx.lineTo(10, -28);
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle = '#c6a700';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // "BS" on hat
  ctx.fillStyle = '#1a0a2e';
  ctx.font = 'bold 9px Fredoka';
  ctx.textAlign = 'center';
  ctx.fillText('BS', 0, -32);

  // Eyes
  const eyeOffX = Math.cos(angle) * 2;
  const eyeOffY = Math.sin(angle) * 1;
  ctx.fillStyle = '#333';
  ctx.beginPath();
  ctx.arc(-4 + eyeOffX, -19 + eyeOffY, 2, 0, Math.PI*2);
  ctx.arc(4 + eyeOffX, -19 + eyeOffY, 2, 0, Math.PI*2);
  ctx.fill();

  // Smile
  ctx.strokeStyle = '#a66a2a';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.arc(0, -15, 4, 0.2, Math.PI-0.2);
  ctx.stroke();

  // Yellow details
  ctx.fillStyle = '#ffd600';
  ctx.fillRect(-16, 0, 4, 10);
  ctx.fillRect(12, 0, 4, 10);

  // Weapon arm
  ctx.save();
  ctx.rotate(angle);
  ctx.fillStyle = '#ffcc80';
  ctx.fillRect(10, -4, 18, 8);
  ctx.fillStyle = '#8d6e63';
  ctx.fillRect(25, -3, 16, 6);
  ctx.fillStyle = '#6d4c41';
  ctx.fillRect(25, -3, 16, 2);
  ctx.fillStyle = '#bdbdbd';
  ctx.beginPath();
  ctx.arc(45, 0, 9, 0, Math.PI*2);
  ctx.fill();
  ctx.strokeStyle = '#9e9e9e';
  ctx.lineWidth = 1.5;
  ctx.stroke();
  ctx.fillStyle = 'rgba(255,255,255,0.4)';
  ctx.beginPath();
  ctx.arc(43, -3, 3, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();

  // Invincibility glow
  if (player.invincible > 0) {
    ctx.strokeStyle = `rgba(0,229,255,${0.3 + Math.sin(Date.now()/80)*0.3})`;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(0, 0, 35, 0, Math.PI*2);
    ctx.stroke();
  }

  ctx.restore();
}

function drawRecipe() {
  const r = recipe;
  const pulse = Math.sin(Date.now() / 500) * 3;

  const grad = ctx.createRadialGradient(r.x, r.y, 10, r.x, r.y, 50 + pulse);
  grad.addColorStop(0, 'rgba(255,214,0,0.3)');
  grad.addColorStop(1, 'rgba(255,214,0,0)');
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(r.x, r.y, 50 + pulse, 0, Math.PI*2);
  ctx.fill();

  ctx.fillStyle = '#5d4037';
  ctx.fillRect(r.x - 22, r.y - 16, 44, 32);
  ctx.fillStyle = '#8d6e63';
  ctx.fillRect(r.x - 20, r.y - 14, 40, 28);
  ctx.strokeStyle = '#ffd600';
  ctx.lineWidth = 2;
  ctx.strokeRect(r.x - 20, r.y - 14, 40, 28);

  ctx.fillStyle = '#fff8e1';
  ctx.fillRect(r.x - 17, r.y - 11, 34, 22);

  ctx.fillStyle = '#4e342e';
  ctx.fillRect(r.x - 1, r.y - 16, 2, 32);

  ctx.fillStyle = '#bcaaa4';
  for (let i = 0; i < 3; i++) ctx.fillRect(r.x + 4, r.y - 7 + i * 6, 12, 2);

  ctx.fillStyle = '#ffd600';
  ctx.font = 'bold 12px Fredoka';
  ctx.textAlign = 'center';
  ctx.fillText('‚≠ê', r.x - 10, r.y + 5);

  ctx.fillStyle = '#ffd600';
  ctx.font = 'bold 10px Fredoka';
  ctx.fillText('RECEITA', r.x, r.y + 38);
  ctx.fillText('SECRETA', r.x, r.y + 50);
}

function drawEnemy(e) {
  ctx.save();
  ctx.translate(e.x, e.y);
  const flash = e.flash > 0;

  if (e.type === 'grunt') {
    ctx.fillStyle = flash ? '#fff' : '#7b1fa2';
    ctx.beginPath();
    ctx.ellipse(0, 2, e.radius, e.radius * 1.2, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = flash ? '#fff' : '#311b92';
    ctx.beginPath();
    ctx.ellipse(0, -4, 10, 8, 0, Math.PI, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = '#ff1744';
    ctx.beginPath();
    ctx.arc(-4, -6, 3, 0, Math.PI*2);
    ctx.arc(4, -6, 3, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(-4, -7, 1, 0, Math.PI*2);
    ctx.arc(4, -7, 1, 0, Math.PI*2);
    ctx.fill();
  } else if (e.type === 'fast') {
    ctx.fillStyle = flash ? '#fff' : '#e65100';
    ctx.beginPath();
    ctx.ellipse(0, 0, e.radius, e.radius, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = '#d50000';
    ctx.fillRect(-e.radius, -3, e.radius*2, 5);
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(-3, -2, 2.5, 0, Math.PI*2);
    ctx.arc(3, -2, 2.5, 0, Math.PI*2);
    ctx.fill();
  } else if (e.type === 'tank') {
    ctx.fillStyle = flash ? '#fff' : '#b71c1c';
    ctx.beginPath();
    ctx.ellipse(0, 2, e.radius, e.radius*1.1, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = '#880e4f';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(0, 2, e.radius - 4, 0, Math.PI*2);
    ctx.stroke();
    ctx.fillStyle = '#ffeb3b';
    ctx.beginPath();
    ctx.arc(-6, -4, 4, 0, Math.PI*2);
    ctx.arc(6, -4, 4, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = '#b71c1c';
    ctx.beginPath();
    ctx.arc(-6, -4, 2, 0, Math.PI*2);
    ctx.arc(6, -4, 2, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = '#880e4f';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-10,-8); ctx.lineTo(-4,-6);
    ctx.moveTo(10,-8); ctx.lineTo(4,-6);
    ctx.stroke();
  }

  if (e.hp < e.maxHp) {
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(-e.radius, -e.radius - 8, e.radius*2, 4);
    ctx.fillStyle = '#00e676';
    ctx.fillRect(-e.radius, -e.radius - 8, e.radius*2*(e.hp/e.maxHp), 4);
  }

  ctx.restore();
}

function drawBullet(b) {
  ctx.save();
  ctx.translate(b.x, b.y);
  ctx.fillStyle = b.color;
  ctx.beginPath();
  ctx.arc(0, 0, b.radius, 0, Math.PI*2);
  ctx.fill();
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.beginPath();
  ctx.arc(-2, -2, b.radius * 0.4, 0, Math.PI*2);
  ctx.fill();
  const sc = ['#ff1744','#ffd600','#00e676','#2979ff'];
  for (let i = 0; i < 3; i++) {
    ctx.fillStyle = sc[i % sc.length];
    const a = (Date.now()/200 + i*2.1);
    ctx.fillRect(Math.cos(a)*4 - 1, Math.sin(a)*4 - 1, 2, 2);
  }
  ctx.restore();
}

function drawParticles() {
  particles.forEach(p => {
    const alpha = p.life / p.maxLife;
    ctx.globalAlpha = alpha;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.radius * alpha, 0, Math.PI*2);
    ctx.fill();
  });
  ctx.globalAlpha = 1;
}

function drawBackground() {
  ctx.fillStyle = '#1a1a2e';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.strokeStyle = 'rgba(0,229,255,0.06)';
  ctx.lineWidth = 1;
  const tileSize = 60;
  for (let x = 0; x < canvas.width; x += tileSize) {
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
  }
  for (let y = 0; y < canvas.height; y += tileSize) {
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
  }

  ctx.fillStyle = 'rgba(0,229,255,0.04)';
  ctx.beginPath(); ctx.arc(0, 0, 200, 0, Math.PI/2); ctx.fill();
  ctx.beginPath(); ctx.arc(canvas.width, canvas.height, 200, Math.PI, Math.PI*1.5); ctx.fill();

  for (let i = 0; i < 20; i++) {
    const t = Date.now()/3000 + i * 137.5;
    const x = ((Math.sin(t * 0.7 + i) + 1) / 2) * canvas.width;
    const y = ((Math.cos(t * 0.5 + i * 0.8) + 1) / 2) * canvas.height;
    ctx.fillStyle = `rgba(255,214,0,${0.03 + Math.sin(t)*0.02})`;
    ctx.beginPath(); ctx.arc(x, y, 2, 0, Math.PI*2); ctx.fill();
  }
}

function drawWaveAnnounce() {
  if (waveAnnounceTimer > 0) {
    const alpha = waveAnnounceTimer > 60 ? 1 : waveAnnounceTimer / 60;
    const scale = waveAnnounceTimer > 90 ? 0.5 + (120 - waveAnnounceTimer) / 60 : 1;
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.translate(canvas.width/2, canvas.height/2 - 80);
    ctx.scale(scale, scale);
    ctx.font = `${isMobile ? 32 : 48}px "Bungee Shade"`;
    ctx.fillStyle = '#ffd600';
    ctx.textAlign = 'center';
    ctx.shadowColor = 'rgba(255,214,0,0.6)';
    ctx.shadowBlur = 30;
    ctx.fillText(waveAnnounce, 0, 0);
    ctx.shadowBlur = 0;
    ctx.restore();
  }
}

// ====== CROSSHAIR ======
function drawCrosshair() {
  if (!isMobile && gameState === 'playing') return; // Desktop uses CSS cursor
  if (gameState !== 'playing') return;

  ctx.save();
  ctx.translate(mouse.x, mouse.y);
  ctx.strokeStyle = 'rgba(255,214,0,0.7)';
  ctx.lineWidth = 2;

  // Outer ring
  ctx.beginPath();
  ctx.arc(0, 0, 18, 0, Math.PI*2);
  ctx.stroke();

  // Cross lines
  ctx.beginPath();
  ctx.moveTo(-24, 0); ctx.lineTo(-10, 0);
  ctx.moveTo(10, 0); ctx.lineTo(24, 0);
  ctx.moveTo(0, -24); ctx.lineTo(0, -10);
  ctx.moveTo(0, 10); ctx.lineTo(0, 24);
  ctx.stroke();

  // Center dot
  ctx.fillStyle = '#ffd600';
  ctx.beginPath();
  ctx.arc(0, 0, 3, 0, Math.PI*2);
  ctx.fill();

  ctx.restore();
}

// ====== UPDATE ======

function update() {
  if (gameState !== 'playing') return;

  // Player movement (keyboard + joystick)
  let dx = joystickInput.x;
  let dy = joystickInput.y;
  if (keys['w'] || keys['arrowup']) dy -= 1;
  if (keys['s'] || keys['arrowdown']) dy += 1;
  if (keys['a'] || keys['arrowleft']) dx -= 1;
  if (keys['d'] || keys['arrowright']) dx += 1;

  const len = Math.sqrt(dx*dx + dy*dy);
  if (len > 0.1) {
    const norm = Math.min(len, 1);
    player.x += (dx/len) * norm * player.speed;
    player.y += (dy/len) * norm * player.speed;
  }

  player.x = Math.max(20, Math.min(canvas.width - 20, player.x));
  player.y = Math.max(20, Math.min(canvas.height - 20, player.y));

  if (player.shootCooldown > 0) player.shootCooldown--;
  if (player.invincible > 0) player.invincible--;

  // Auto-aim for mobile if no explicit aim
  if (isMobile && !mouse.active && enemies.length > 0) {
    let closestDist = Infinity;
    let closest = null;
    enemies.forEach(e => {
      const d = Math.sqrt((e.x - player.x)**2 + (e.y - player.y)**2);
      if (d < closestDist) { closestDist = d; closest = e; }
    });
    if (closest) {
      mouse.x = closest.x;
      mouse.y = closest.y;
    }
  }

  // Spawn
  spawnTimer--;
  if (spawnTimer <= 0 && enemiesLeftInWave > 0) {
    spawnEnemy();
    spawnTimer = spawnInterval;
  }

  // Bullets
  bullets.forEach(b => { b.x += b.vx; b.y += b.vy; b.life--; });
  bullets = bullets.filter(b => b.life > 0 && b.x > -50 && b.x < canvas.width+50 && b.y > -50 && b.y < canvas.height+50);

  // Enemies
  enemies.forEach(e => {
    const edx = recipe.x - e.x, edy = recipe.y - e.y;
    const dist = Math.sqrt(edx*edx + edy*edy);
    if (dist > 5) { e.x += (edx/dist)*e.speed; e.y += (edy/dist)*e.speed; }
    if (e.flash > 0) e.flash--;
    if (e.attackCooldown > 0) e.attackCooldown--;
    if (dist < recipe.radius + e.radius + 5 && e.attackCooldown <= 0) {
      recipeHealth -= e.damage;
      e.attackCooldown = 60;
      shakeTimer = 10;
      addExplosion(recipe.x, recipe.y, '#ff1744', 6);
    }
  });

  // Bullet-Enemy collisions
  for (let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];
    for (let j = enemies.length - 1; j >= 0; j--) {
      const e = enemies[j];
      const dist = Math.sqrt((b.x-e.x)**2 + (b.y-e.y)**2);
      if (dist < b.radius + e.radius) {
        e.hp--; e.flash = 6;
        bullets.splice(i, 1);
        addExplosion(b.x, b.y, b.color, 5);
        if (e.hp <= 0) {
          addExplosion(e.x, e.y, e.color, 15);
          score += e.type === 'tank' ? 30 : e.type === 'fast' ? 15 : 10;
          enemies.splice(j, 1);
          if (Math.random() < 0.1) {
            powerups.push({ x: e.x, y: e.y, type: Math.random() < 0.5 ? 'heal' : 'speed', life: 300, radius: 12 });
          }
        }
        break;
      }
    }
  }

  // Player-Powerup
  for (let i = powerups.length - 1; i >= 0; i--) {
    const p = powerups[i];
    p.life--;
    const dist = Math.sqrt((player.x-p.x)**2 + (player.y-p.y)**2);
    if (dist < 30) {
      if (p.type === 'heal') { recipeHealth = Math.min(100, recipeHealth + 20); addExplosion(p.x, p.y, '#00e676', 10); }
      else { player.invincible = 180; addExplosion(p.x, p.y, '#00e5ff', 10); }
      powerups.splice(i, 1);
    }
  }
  powerups = powerups.filter(p => p.life > 0);

  // Particles
  particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.vx *= 0.96; p.vy *= 0.96; p.life--; });
  particles = particles.filter(p => p.life > 0);

  // Wave check
  if (enemies.length === 0 && enemiesLeftInWave <= 0 && !waveTransition) {
    waveTransition = true;
    if (wave >= maxWaves) {
      setTimeout(() => {
        gameState = 'win';
        document.getElementById('win-score-val').textContent = score;
        document.getElementById('win-screen').style.display = 'flex';
        showUI(false);
      }, 500);
    } else {
      setTimeout(() => startWave(wave + 1), 2000);
    }
  }

  // Game over
  if (recipeHealth <= 0) {
    gameState = 'gameover';
    document.getElementById('final-score-val').textContent = score;
    document.getElementById('game-over-screen').style.display = 'flex';
    showUI(false);
  }

  if (waveAnnounceTimer > 0) waveAnnounceTimer--;
  if (shakeTimer > 0) shakeTimer--;
  updateHUD();
}

// ====== MAIN LOOP ======

function draw() {
  ctx.save();
  if (shakeTimer > 0) {
    ctx.translate((Math.random()-0.5)*shakeTimer*2, (Math.random()-0.5)*shakeTimer*2);
  }
  drawBackground();

  if (gameState === 'playing' || gameState === 'gameover' || gameState === 'win') {
    drawRecipe();
    drawParticles();

    powerups.forEach(p => {
      const bob = Math.sin(Date.now() / 300) * 3;
      ctx.save();
      ctx.translate(p.x, p.y + bob);
      ctx.fillStyle = p.type === 'heal' ? '#00e676' : '#00e5ff';
      ctx.beginPath(); ctx.arc(0, 0, p.radius, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.font = p.type === 'heal' ? 'bold 14px Fredoka' : 'bold 11px Fredoka';
      ctx.textAlign = 'center';
      ctx.fillText(p.type === 'heal' ? '+' : '‚ö°', 0, p.type === 'heal' ? 5 : 4);
      ctx.restore();
    });

    bullets.forEach(drawBullet);
    enemies.forEach(drawEnemy);
    drawPlayer();
    drawCrosshair();
    drawWaveAnnounce();
  }
  ctx.restore();
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

// ====== START BUTTONS ======
function startGame() {
  gameState = 'playing';
  showUI(true);
  initGame();
}

document.getElementById('btn-start').addEventListener('click', () => {
  document.getElementById('start-screen').style.display = 'none';
  startGame();
});
document.getElementById('btn-restart').addEventListener('click', () => {
  document.getElementById('game-over-screen').style.display = 'none';
  startGame();
});
document.getElementById('btn-win-restart').addEventListener('click', () => {
  document.getElementById('win-screen').style.display = 'none';
  startGame();
});

loop();
</script>
</body>
</html>
